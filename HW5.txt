¬ дз реализован паттерн ÷епь ответственности. ѕри сохранении заказа в базе на основании адреса определ€етс€ какой конкретный магазин будет обслуживать данный заказ.
¬ магазине существует р€д рабочих мест, на которых повара изготавливают необходимые блюда. ¬се рабочие места организованы в цепь ответственности, в которой на основе
загрузки этих мест принимаетс€ решение о вз€тии блюда в работу. ¬се необработанные блюда хран€тс€ в сптске магазина, по определенному регламенту этот список раз за разом 
отправл€етс€ в обработку.

@Service
public class OrderService {
    private OrderRepository orderRepository;
    private AdressRepository adressRepository;
    private HashMap<String,Shop> shopList;

    public void saveOrder(SalesOrder order){
        orderRepository.save(order);
        Adress ad = adressRepository.findOneByAdress(order.getDeliveryAddress());
        Shop shop = shopList.get(ad.getAreaID());
        shop.startCooking(order);
    }
}

public interface AdressRepository extends PagingAndSortingRepository<Adress, Long> {
    @Query("SELECT  ad FROM  Adress ad WHERE ad.adress =:ad")
    Adress findOneByAdress(@Param("ad") String ad);
}

@Entity
@Table(name = "adress")
@Data
public class Adress {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "create_at")
    private String adress;

    @Column
    private String areaID;

}

public abstract class Workplace {
    private Workplace next;

    public Workplace setNext(Workplace next){
        this.next = next;
        return next;
    }

    public void handle(Dish dish){
        if(next != null)
            next.handle(dish);
    }

    public Workplace getNext() {
        return next;
    }
}

public class Cook extends Workplace {
    private int queueTime;
    private int currentTimeAmount;
    private ArrayList<Dish> workList;

    public int getQueueTime() {
        return queueTime;
    }

    public void setQueueTime(int queueTime) {
        this.queueTime = queueTime;
    }

    @Override
    public void handle(Dish dish){
        int incomingTimeAmount = dish.getCookTime();
        if (queueTime < currentTimeAmount + incomingTimeAmount){
            workList.add(dish);
            currentTimeAmount = currentTimeAmount + incomingTimeAmount;
            System.out.println(dish.toString() + " in progress");
        } else {
            super.handle(dish);
        }
    }

    public boolean removeDish(Dish dish){
        if (workList.contains(dish)){
            workList.remove(dish);
            currentTimeAmount = currentTimeAmount - dish.getCookTime();
            return true;
        }else{
            return false;
        }
    }

}

public class Shop{
    private Workplace workplaceChain;
    private ArrayList<Dish> dishesWaiting;
    private Final finalHandler = new Final();

    public void addWorkplace(Cook workplace){
        if (workplaceChain == null){
            workplaceChain = finalHandler;
            workplaceChain.setNext(workplace);
            workplaceChain.setNext(finalHandler);
        }else{
            Workplace temp = workplaceChain;
            while (!temp.getNext().equals(finalHandler)){
                temp = temp.getNext();
            }
            temp.setNext(workplace);
            workplace.setNext(finalHandler);
        }
    }
    
    public void startCooking(SalesOrder order){
        ArrayList<Dish> dishList = order.getAllDishes();
        for (Dish dish: dishList) {
            dishesWaiting.add(dish);
        }
    }

    public void handleDishList(){
        for (Dish dish: dishesWaiting) {
            workplaceChain.handle(dish);
        }
    }
}



